<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Crocodile Mini App</title>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <style>
        html, body {
            margin: 0; padding: 0;
            height: 100%;
            background: #1c1c1e;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            user-select: none;
        }

        body { display: flex; flex-direction: column; }

        canvas {
            flex: 1;
            background: #ffffff;
            touch-action: none;
            display: block;
        }

        .toolbar {
            height: 64px;
            background: #2c2c2e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            border-top: 1px solid #3a3a3c;
            box-sizing: border-box;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toolbar input[type="color"] {
            width: 40px; height: 40px;
            border-radius: 50%;
            border: 2px solid #fff;
            padding: 0;
            background: none;
        }

        .btn {
            color: #ffffff;
            border: none;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-blue { background: #007aff; }
        .btn-red { background: #ff3b30; }
        .btn-gray { background: #3a3a3c; }

        .btn:active { opacity: 0.7; }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="toolbar">
    <div class="toolbar-group">
        <input type="color" id="brushColor" value="#000000" />
        <button id="clearBtn" class="btn btn-gray">üßπ</button>
        <!-- –ö–Ω–æ–ø–∫–∞ –ø—Ä–æ–ø—É—Å–∫–∞ –≤ WebApp (–¥—É–±–ª–∏—Ä—É–µ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –±–æ—Ç–∞) -->
        <button id="skipBtn" class="btn btn-blue">–°–ª–æ–≤–æ üîÑ</button>
    </div>
    <button id="finishBtn" class="btn btn-red">–ì–æ—Ç–æ–≤–æ</button>
</div>

<script>
    // ---------------- TELEGRAM INIT ----------------
    const tg = window.Telegram.WebApp;
    tg.expand();
    tg.ready();
    tg.enableClosingConfirmation();

    const roomId = tg.initDataUnsafe.start_param;

    if (!roomId) alert("–û—à–∏–±–∫–∞: –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω chat_id");

    // ---------------- CANVAS INIT ----------------
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    
    // –§–ª–∞–≥ –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–µ–≤—å—é
    let isDirty = false;

    function resizeCanvas() {
        const toolbarHeight = document.querySelector('.toolbar').offsetHeight;
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        if (canvas.width > 0) tempCtx.drawImage(canvas, 0, 0);

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - toolbarHeight;

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = 6;
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (tempCanvas.width > 0) ctx.drawImage(tempCanvas, 0, 0);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ---------------- SOCKET.IO ----------------
    const socket = io({ transports: ['websocket', 'polling'] });

    socket.on('connect', () => {
        console.log('[socket] connected');
        socket.emit('join_room', { room: roomId });
    });

    socket.on('draw_data', (data) => {
        drawStroke(data.px, data.py, data.x, data.y, data.color, false);
    });

    socket.on('new_word_data', (data) => {
        tg.showPopup({
            title: '–ù–æ–≤–æ–µ —Å–ª–æ–≤–æ',
            message: data.word.toUpperCase(),
            buttons: [{type: 'ok', text: '–ü–æ–Ω—è–ª'}]
        });
        clearCanvas();
    });

    // ---------------- DRAWING LOGIC ----------------
    let drawing = false;
    let lastPos = { x: 0, y: 0 };

    const getPos = (e) => {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top,
        };
    };

    function drawStroke(x1, y1, x2, y2, color, emit = true) {
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        if (emit) {
            isDirty = true;
            socket.emit('draw_step', {
                room: roomId,
                px: x1, py: y1,
                x: x2, y: y2,
                color: color,
            });
        }
    }

    // Event Listeners
    canvas.addEventListener('mousedown', (e) => {
        drawing = true;
        lastPos = getPos(e);
    });
    canvas.addEventListener('mousemove', (e) => {
        if (!drawing) return;
        const pos = getPos(e);
        const color = document.getElementById('brushColor').value;
        drawStroke(lastPos.x, lastPos.y, pos.x, pos.y, color, true);
        lastPos = pos;
    });
    window.addEventListener('mouseup', () => { drawing = false; });

    canvas.addEventListener('touchstart', (e) => {
        drawing = true;
        lastPos = getPos(e);
        e.preventDefault();
    }, { passive: false });
    
    canvas.addEventListener('touchmove', (e) => {
        if (!drawing) return;
        const pos = getPos(e);
        const color = document.getElementById('brushColor').value;
        drawStroke(lastPos.x, lastPos.y, pos.x, pos.y, color, true);
        lastPos = pos;
        e.preventDefault();
    }, { passive: false });
    
    window.addEventListener('touchend', () => { drawing = false; });

    // ---------------- FEATURES ----------------

    function clearCanvas() {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        isDirty = true; 
    }

    document.getElementById('clearBtn').onclick = clearCanvas;

    document.getElementById('skipBtn').onclick = () => {
        tg.showConfirm("–°–¥–∞—Ç—å—Å—è –∏ –≤–∑—è—Ç—å –¥—Ä—É–≥–æ–µ —Å–ª–æ–≤–æ?", (ok) => {
            if (ok) {
                // –ï—Å–ª–∏ –ª–æ–≥–∏–∫–∞ —Å–º–µ–Ω—ã —Å–ª–æ–≤–∞ –µ—Å—Ç—å –∏ –Ω–∞ –∫–Ω–æ–ø–∫–µ –≤ —á–∞—Ç–µ, 
                // –∏ –∑–¥–µ—Å—å, —Ç–æ –≤—ã–∑—ã–≤–∞–µ–º —Å–µ—Ä–≤–µ—Ä–Ω—ã–π –º–µ—Ç–æ–¥
                socket.emit('skip_turn', { room: roomId });
            }
        });
    };

    document.getElementById('finishBtn').onclick = () => {
        tg.showConfirm("–ó–∞–≤–µ—Ä—à–∏—Ç—å —Ä–∞—É–Ω–¥ –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∏—Å—É–Ω–æ–∫?", (ok) => {
            if (ok) {
                const image = canvas.toDataURL('image/jpeg', 0.85);
                socket.emit('final_frame', { room: roomId, image: image });
                tg.close();
            }
        });
    };

    // ---------------- LIVE PREVIEW LOOP ----------------
    setInterval(() => {
        if (isDirty && socket.connected) {
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∂–∞—Ç—ã–π —Å–Ω–∞–ø—à–æ—Ç
            const previewImage = canvas.toDataURL('image/jpeg', 0.3);
            socket.emit('preview_snapshot', {
                room: roomId,
                image: previewImage
            });
            isDirty = false;
        }
    }, 4000); // 4 —Å–µ–∫—É–Ω–¥—ã –∏–Ω—Ç–µ—Ä–≤–∞–ª
</script>

</body>
</html>
